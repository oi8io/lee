package questions

import "fmt"

//给你一个字符串 s，找到 s 中最长的回文子串。
//
//
//
// 示例 1：
//
//
//输入：s = "babad"
//输出："bab"
//解释："aba" 同样是符合题意的答案。
//
//
// 示例 2：
//
//
//输入：s = "cbbd"
//输出："bb"
//
//
//
//
// 提示：
//
//
// 1 <= s.length <= 1000
// s 仅由数字和英文字母组成
//
/**
【暴力破解】（有点动态规划）
特征分析：出现回文的条件就是出现重复字符，判断上次出现该字符的时候是否形成回文，上上次，一直到第一次出现该字符的时候去判断。
如果长度超过当前最长的长度，则替换返回值为当前。
有两种情况：
1. 没有找到重复字符的情况下,返回第一个字符即可
2. 只有单个字符的情况下,返回字符串本身
> 切片下标从起始下标到
*/
//leetcode submit region begin(Prohibit modification and deletion)
func longestPalindrome(s string) string {
	if len(s) > 1000 {
		s = s[:1000]
	}
	rs := reverse(s)
	if s == rs {
		return s
	}
	length := len(rs)
	var max int
	var result string
	// 存放重复字符
	vmap := make(map[byte][]int)
	for end := 0; end < len(s); end++ {
		// 遍历重复字符位置
		for _, start := range vmap[s[end]] {
			if end+1-start <= max { //没有之前的回文长，则就不需要去比较了
				continue
			}
			str := s[start : end+1]                //找出字符串 aba abca
			rev := rs[length-end-1 : length-start] // 找到反转字符串中对应的反转字符
			//fmt.Printf("at[%d:%d],[%s<>%s]\n", start, end, str, rev)
			if str == rev { //是回文
				max = end + 1 - start
				result = s[start : end+1]
			}
		}
		vmap[s[end]] = append(vmap[s[end]], end)
	}
	if result == "" {
		result = string(s[0])
	}
	return result
}

func reverse(s string) string {
	var str []byte
	for i := len(s) - 1; i >= 0; i-- {
		str = append(str, s[i])
	}
	return string(str)
}

func longestPalindromeSolution2(s string) string {
	n := len(s)
	var start, end, lengh, gStart, i int
	for i < n {
		start = i
		end = i
		for end+1 < n && s[end] == s[end+1] { //same char
			end++
		}
		i = end + 1
		for start-1 >= 0 && end+1 < n && s[start-1] == s[end+1] {
			start--
			end++
		}
		if end-start+1 > lengh {
			lengh = end - start + 1
			gStart = start
		}
		fmt.Println("[", start, end, "]", gStart, lengh, "<------>", s[gStart:gStart+lengh])
	}
	return s[gStart : gStart+lengh]
}

//leetcode submit region end(Prohibit modification and deletion)

//321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123
//321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123210012321001232100123210123
